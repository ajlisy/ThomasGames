<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            text-align: center;
        }
        canvas {
            border: 4px solid #fff;
            display: block;
            margin: 0 auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        #score {
            color: #fff;
            font-size: 28px;
            margin-top: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #instructions {
            color: #ccc;
            font-size: 16px;
            margin-top: 15px;
        }
        #backButton {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #backButton:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="snakeCanvas" width="600" height="600"></canvas>
        <div id="score">Score: 0 | High Score: 0</div>
        <div id="instructions">Use Arrow Keys to move | Press SPACE to start</div>
        <button id="backButton" onclick="window.location.href='index.html'">Back to Menu</button>
    </div>

    <script>
        const canvas = document.getElementById('snakeCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        const GRID_SIZE = 25;
        const TILE_COUNT = 15;
        const TILE_HEIGHT = 12;
        const ISO_ANGLE = Math.PI / 6; // 30 degrees for isometric

        // Convert 3D isometric coordinates to 2D screen coordinates
        function iso3D(x, y, z) {
            const screenX = (x - y) * Math.cos(ISO_ANGLE);
            const screenY = (x + y) * Math.sin(ISO_ANGLE) - z;
            return {
                x: canvas.width / 2 + screenX,
                y: canvas.height / 2 + screenY
            };
        }

        let gameState = {
            snake: [{x: 10, y: 10}],
            dx: 0,
            dy: 0,
            food: {x: 15, y: 15, scale: 0},
            score: 0,
            highScore: localStorage.getItem('snakeHighScore') || 0,
            gameStarted: false,
            gameOver: false,
            speed: 100,
            moveProgress: 0,
            particles: []
        };

        let lastMoveTime = 0;
        let nextDirection = {dx: 0, dy: 0};

        function createEatParticles(x, y, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                gameState.particles.push({
                    x: x * GRID_SIZE + GRID_SIZE / 2,
                    y: y * GRID_SIZE + GRID_SIZE / 2,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    life: 1.0,
                    size: 3 + Math.random() * 3
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                if (!gameState.gameStarted || gameState.gameOver) {
                    startGame();
                }
            }

            if (!gameState.gameStarted) return;

            switch(e.key) {
                case 'ArrowUp':
                    if (gameState.dy === 0) {
                        nextDirection = {dx: 0, dy: -1};
                    }
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    if (gameState.dy === 0) {
                        nextDirection = {dx: 0, dy: 1};
                    }
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    if (gameState.dx === 0) {
                        nextDirection = {dx: -1, dy: 0};
                    }
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    if (gameState.dx === 0) {
                        nextDirection = {dx: 1, dy: 0};
                    }
                    e.preventDefault();
                    break;
            }
        });

        function startGame() {
            const newFood = generateFood();
            gameState = {
                snake: [{x: 10, y: 10}],
                dx: 1,
                dy: 0,
                food: newFood,
                score: 0,
                highScore: gameState.highScore,
                gameStarted: true,
                gameOver: false,
                speed: 100,
                moveProgress: 0,
                particles: []
            };
            nextDirection = {dx: 1, dy: 0};
            updateScore();
        }

        function generateFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT),
                    scale: 0
                };
            } while (gameState.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
            return newFood;
        }

        function updateFood() {
            if (gameState.food.scale < 1) {
                gameState.food.scale = Math.min(gameState.food.scale + 0.05, 1);
            }
        }

        function updateScore() {
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('snakeHighScore', gameState.highScore);
            }
            scoreDisplay.textContent = `Score: ${gameState.score} | High Score: ${gameState.highScore}`;
        }

        function moveSnake(currentTime) {
            if (!gameState.gameStarted || gameState.gameOver) return;
            if (currentTime - lastMoveTime < gameState.speed) return;

            lastMoveTime = currentTime;

            gameState.dx = nextDirection.dx;
            gameState.dy = nextDirection.dy;

            const head = {
                x: gameState.snake[0].x + gameState.dx,
                y: gameState.snake[0].y + gameState.dy
            };

            if (head.x < 0 || head.x >= TILE_COUNT ||
                head.y < 0 || head.y >= TILE_COUNT ||
                gameState.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameState.gameOver = true;
                return;
            }

            gameState.snake.unshift(head);

            if (head.x === gameState.food.x && head.y === gameState.food.y) {
                gameState.score++;
                createEatParticles(gameState.food.x, gameState.food.y);
                gameState.food = generateFood();
                gameState.speed = Math.max(50, gameState.speed - 2);
                updateScore();
            } else {
                gameState.snake.pop();
            }
        }

        function drawCube(x, y, z, size, color, outline) {
            // Draw an isometric cube with proper faces
            const corner1 = iso3D(x, y, z);
            const corner2 = iso3D(x + size, y, z);
            const corner3 = iso3D(x, y + size, z);
            const corner4 = iso3D(x + size, y + size, z);
            const corner5 = iso3D(x, y, z + TILE_HEIGHT);
            const corner6 = iso3D(x + size, y, z + TILE_HEIGHT);
            const corner7 = iso3D(x, y + size, z + TILE_HEIGHT);
            const corner8 = iso3D(x + size, y + size, z + TILE_HEIGHT);

            // Left side face (darker)
            ctx.fillStyle = adjustBrightness(color, -0.3);
            ctx.beginPath();
            ctx.moveTo(corner1.x, corner1.y);
            ctx.lineTo(corner3.x, corner3.y);
            ctx.lineTo(corner7.x, corner7.y);
            ctx.lineTo(corner5.x, corner5.y);
            ctx.closePath();
            ctx.fill();

            // Right side face (medium)
            ctx.fillStyle = adjustBrightness(color, -0.15);
            ctx.beginPath();
            ctx.moveTo(corner1.x, corner1.y);
            ctx.lineTo(corner2.x, corner2.y);
            ctx.lineTo(corner6.x, corner6.y);
            ctx.lineTo(corner5.x, corner5.y);
            ctx.closePath();
            ctx.fill();

            // Top face (brightest)
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(corner5.x, corner5.y);
            ctx.lineTo(corner6.x, corner6.y);
            ctx.lineTo(corner8.x, corner8.y);
            ctx.lineTo(corner7.x, corner7.y);
            ctx.closePath();
            ctx.fill();
        }

        function adjustBrightness(color, amount) {
            const usePound = color[0] === "#";
            const col = usePound ? color.slice(1) : color;
            const num = parseInt(col, 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + (amount * 255)));
            const g = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) + (amount * 255)));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + (amount * 255)));
            return (usePound ? "#" : "") + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
        }

        function draw() {
            ctx.fillStyle = '#0a1929';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw board
            for (let i = 0; i < TILE_COUNT; i++) {
                for (let j = 0; j < TILE_COUNT; j++) {
                    const color = (i + j) % 2 === 0 ? '#1a3a52' : '#0f2741';
                    drawCube(i * GRID_SIZE, j * GRID_SIZE, -5, GRID_SIZE, color, 'rgba(255,255,255,0.1)');
                }
            }

            // Draw food
            const foodPos = iso3D(
                gameState.food.x * GRID_SIZE + GRID_SIZE / 2 - GRID_SIZE / 2,
                gameState.food.y * GRID_SIZE + GRID_SIZE / 2 - GRID_SIZE / 2,
                0
            );
            const foodScale = GRID_SIZE * 0.4 * gameState.food.scale;
            ctx.fillStyle = '#ef4444';
            ctx.shadowColor = '#ef4444';
            ctx.shadowBlur = 20 * gameState.food.scale;
            ctx.beginPath();
            ctx.arc(foodPos.x + GRID_SIZE / 2, foodPos.y - TILE_HEIGHT / 2, foodScale, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Sort snake segments by position for proper depth ordering
            const snakeSegmentsWithZ = gameState.snake.map((segment, index) => ({
                ...segment,
                index,
                z: segment.x + segment.y
            })).sort((a, b) => a.z - b.z);

            snakeSegmentsWithZ.forEach(({x, y, index}) => {
                const alpha = 1 - (index / gameState.snake.length) * 0.4;
                const color = index === 0
                    ? `rgba(74, 222, 128, ${alpha})`
                    : `rgba(34, 197, 94, ${alpha})`;
                drawCube(x * GRID_SIZE, y * GRID_SIZE, 0, GRID_SIZE, color, 'rgba(0,0,0,0.3)');

                // Draw eyes on head
                if (index === 0) {
                    const headPos = iso3D(x * GRID_SIZE + GRID_SIZE / 2, y * GRID_SIZE + GRID_SIZE / 2, TILE_HEIGHT);
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(headPos.x - 3, headPos.y - 3, 2, 0, Math.PI * 2);
                    ctx.arc(headPos.x + 3, headPos.y - 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Particle effects (simplified for 3D)
            gameState.particles.forEach(p => {
                ctx.fillStyle = `rgba(239, 68, 68, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = '48px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 10;
                ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 30);

                ctx.font = '24px Courier New';
                ctx.fillText(`Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
                ctx.fillText('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 60);
                ctx.shadowBlur = 0;
            }

            if (!gameState.gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = '36px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 10;
                ctx.fillText('Press SPACE to Start', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            }
        }

        function gameLoop(currentTime) {
            moveSnake(currentTime);
            updateParticles();
            updateFood();
            draw();
            requestAnimationFrame(gameLoop);
        }

        updateScore();
        gameLoop(0);
    </script>
</body>
</html>
