<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rooftop Rumble</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #1e3a5f 0%, #2d5a7b 50%, #3a6ea5 100%);
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            text-align: center;
        }
        canvas {
            border: 4px solid #fff;
            display: block;
            margin: 0 auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            background: #87CEEB;
        }
        #score {
            color: #fff;
            font-size: 32px;
            margin-top: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        #instructions {
            color: #ccc;
            font-size: 16px;
            margin-top: 15px;
            line-height: 1.6;
        }
        #backButton {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #backButton:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        <div id="score">Player 1: 0 | Player 2: 0</div>
        <div id="instructions">
            Player 1: W=Left, E=Right, Space=Jump, J=Shoot, K=Switch Weapon | Player 2: WASD=Move/Jump, Q=Shoot, T=Switch Weapon<br>
            Weapons: Pistol, SMG, Shotgun, RPG, Axe | First to 5 wins!
        </div>
        <div id="modeSelect" style="margin-top: 20px;">
            <button id="pvpButton" style="padding: 12px 30px; font-size: 16px; font-family: 'Courier New', monospace; background: rgba(255,255,255,0.2); color: white; border: 2px solid white; border-radius: 8px; cursor: pointer; margin: 0 10px;">Player vs Player</button>
            <button id="aiButton" style="padding: 12px 30px; font-size: 16px; font-family: 'Courier New', monospace; background: rgba(255,255,255,0.2); color: white; border: 2px solid white; border-radius: 8px; cursor: pointer; margin: 0 10px;">Player vs AI</button>
        </div>
        <button id="backButton" onclick="window.location.href='index.html'">Back to Menu</button>
    </div>

    <script src="leaderboard.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        const GRAVITY = 0.6;
        const JUMP_STRENGTH = -12;
        const ROOFTOP_HEIGHT = 450;
        const PLAYER_SIZE = 30;
        const WINNING_SCORE = 5;

        const WEAPONS = {
            pistol: {
                name: 'Pistol',
                fireRate: 500,
                bulletSpeed: 12,
                bulletCount: 1,
                spread: 0,
                recoil: -4,
                damage: 1,
                projectileType: 'bullet'
            },
            smg: {
                name: 'SMG',
                fireRate: 100,
                bulletSpeed: 10,
                bulletCount: 1,
                spread: 0.3,
                recoil: -2,
                damage: 0.5,
                projectileType: 'bullet'
            },
            shotgun: {
                name: 'Shotgun',
                fireRate: 800,
                bulletSpeed: 9,
                bulletCount: 5,
                spread: 0.6,
                recoil: -8,
                damage: 0.75,
                projectileType: 'bullet'
            },
            rpg: {
                name: 'RPG',
                fireRate: 2000,
                bulletSpeed: 8,
                bulletCount: 1,
                spread: 0,
                recoil: -10,
                damage: 2.5,
                projectileType: 'rocket'
            },
            axe: {
                name: 'Axe',
                fireRate: 400,
                bulletSpeed: 0,
                bulletCount: 0,
                spread: 0,
                recoil: 0,
                damage: 1.5,
                projectileType: 'melee'
            },
            thomasagun: {
                name: 'Thomasagun',
                fireRate: 300,
                bulletSpeed: 15,
                bulletCount: 1,
                spread: 0,
                recoil: -6,
                damage: 10,
                projectileType: 'bullet'
            }
        };

        const normalWeaponKeys = ['pistol', 'smg', 'shotgun', 'rpg', 'axe'];
        const weaponKeys = Object.keys(WEAPONS);

        let gameMode = null; // 'pvp' or 'ai'
        let gameStarted = false;
        let secretCode = '';
        let hasSecretWeapon = false;
        let madHoppsActive = false;

        const MAX_HEALTH = 5;

        let gameState = {
            player1: {
                x: 150,
                y: ROOFTOP_HEIGHT - PLAYER_SIZE,
                velocityX: 0,
                velocityY: 0,
                rotation: 0,
                rotationVelocity: 0,
                onGround: true,
                score: 0,
                alive: true,
                health: MAX_HEALTH,
                weapon: 'pistol',
                weaponIndex: 0,
                facingRight: true
            },
            player2: {
                x: 750,
                y: ROOFTOP_HEIGHT - PLAYER_SIZE,
                velocityX: 0,
                velocityY: 0,
                rotation: 0,
                rotationVelocity: 0,
                onGround: true,
                score: 0,
                alive: true,
                health: MAX_HEALTH,
                weapon: 'pistol',
                weaponIndex: 0,
                facingRight: false
            },
            bullets: [],
            particles: [],
            muzzleFlashes: [],
            explosions: [],
            gameOver: false,
            roundOver: false,
            roundResetTime: 0
        };

        let aiState = {
            lastShot: 0,
            lastWeaponSwitch: 0,
            lastJump: 0,
            targetX: 0,
            moveDirection: 0,
            aggressionLevel: 0.7
        };

        document.getElementById('pvpButton').addEventListener('click', () => {
            gameMode = 'pvp';
            gameStarted = true;
            document.getElementById('modeSelect').style.display = 'none';
            if (hasSecretWeapon) {
                document.getElementById('instructions').textContent = 'Player vs Player Mode - THOMASAGUN ACTIVATED!';
            } else {
                document.getElementById('instructions').textContent = 'Player vs Player Mode - First to 5 wins!';
            }
        });

        document.getElementById('aiButton').addEventListener('click', () => {
            gameMode = 'ai';
            gameStarted = true;
            document.getElementById('modeSelect').style.display = 'none';
            if (hasSecretWeapon) {
                document.getElementById('instructions').textContent = 'Player vs AI Mode - THOMASAGUN ACTIVATED!';
            } else {
                document.getElementById('instructions').textContent = 'Player vs AI Mode - First to 5 wins!';
            }
        });

        function createMuzzleFlash(x, y, direction) {
            gameState.muzzleFlashes.push({
                x: x,
                y: y,
                direction: direction,
                life: 1.0
            });
        }

        function createBulletParticles(x, y, count = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (2 + Math.random() * 3),
                    vy: Math.sin(angle) * (2 + Math.random() * 3),
                    life: 1.0,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.vx *= 0.98;
                p.life -= 0.02;
                return p.life > 0;
            });

            gameState.muzzleFlashes = gameState.muzzleFlashes.filter(flash => {
                flash.life -= 0.15;
                return flash.life > 0;
            });
        }

        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            e: false,
            j: false,
            k: false,
            q: false,
            t: false,
            ' ': false
        };

        document.addEventListener('keydown', (e) => {
            if (e.key in keys) {
                keys[e.key] = true;
                e.preventDefault();
            }

            // Check for secret code
            if (!gameStarted && e.key.length === 1) {
                secretCode += e.key.toLowerCase();
                if (secretCode.length > 20) {
                    secretCode = secretCode.slice(-20);
                }
                if (secretCode.includes('thomas')) {
                    hasSecretWeapon = true;
                    gameState.player1.weapon = 'thomasagun';
                    gameState.player1.weaponIndex = weaponKeys.indexOf('thomasagun');
                    console.log('Secret weapon unlocked: Thomasagun!');
                }
                if (secretCode.includes('mad hopps')) {
                    madHoppsActive = true;
                    console.log('Cheat activated: Mad Hopps!');
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
            }
        });

        function jump(player) {
            if (player.onGround && player.alive) {
                // Apply super jump for player 1 if mad hopps is active
                if (player === gameState.player1 && madHoppsActive) {
                    player.velocityY = JUMP_STRENGTH * 2.5; // Much higher jump
                } else {
                    player.velocityY = JUMP_STRENGTH;
                }
                player.onGround = false;
            }
        }

        function switchWeapon(player) {
            // Only Player 1 can use secret weapon
            const availableWeapons = (player === gameState.player1 && hasSecretWeapon) ? weaponKeys : normalWeaponKeys;

            // Find current weapon in available list
            let currentIndex = availableWeapons.indexOf(player.weapon);
            if (currentIndex === -1) currentIndex = 0;

            // Switch to next weapon
            player.weaponIndex = (currentIndex + 1) % availableWeapons.length;
            player.weapon = availableWeapons[player.weaponIndex];
        }

        function shoot(player) {
            if (!player.alive) return;

            const weapon = WEAPONS[player.weapon];
            const direction = player.facingRight ? 1 : -1;

            if (weapon.projectileType === 'melee') {
                meleeAttack(player, direction);
                return;
            }

            const gunEndX = player.x + PLAYER_SIZE / 2 + direction * (PLAYER_SIZE / 2 + 20);
            const gunEndY = player.y + PLAYER_SIZE / 2;

            for (let i = 0; i < weapon.bulletCount; i++) {
                const spreadAngle = (Math.random() - 0.5) * weapon.spread;
                const angle = Math.atan2(-2, direction * weapon.bulletSpeed) + spreadAngle;

                gameState.bullets.push({
                    x: gunEndX,
                    y: gunEndY,
                    velocityX: Math.cos(angle) * weapon.bulletSpeed,
                    velocityY: Math.sin(angle) * weapon.bulletSpeed,
                    owner: player,
                    trail: [],
                    type: weapon.projectileType,
                    damage: weapon.damage,
                    isThomas: player.weapon === 'thomasagun'
                });
            }

            createMuzzleFlash(gunEndX, gunEndY, direction);

            player.velocityY = weapon.recoil;
            player.rotationVelocity = direction * -0.4;
        }

        function meleeAttack(player, direction) {
            const attackRange = 50;
            const attackX = player.x + (direction > 0 ? PLAYER_SIZE : 0) + direction * attackRange;
            const attackY = player.y + PLAYER_SIZE / 2;
            const weapon = WEAPONS[player.weapon];

            [gameState.player1, gameState.player2].forEach(target => {
                if (target !== player && target.alive) {
                    const dx = target.x + PLAYER_SIZE / 2 - attackX;
                    const dy = target.y + PLAYER_SIZE / 2 - attackY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < attackRange) {
                        target.health -= weapon.damage;
                        target.velocityY = -12;
                        target.velocityX = direction * 15;
                        target.rotationVelocity = direction * 0.8;
                        createBulletParticles(target.x + PLAYER_SIZE / 2, target.y + PLAYER_SIZE / 2, 15);

                        if (target.health <= 0) {
                            target.health = 0;
                            target.alive = false;
                        }
                    }
                }
            });

            player.rotationVelocity = direction * -0.6;
        }

        let lastShot1 = 0;
        let lastShot2 = 0;
        let lastWeaponSwitch1 = 0;
        let lastWeaponSwitch2 = 0;

        function updateAI() {
            if (gameMode !== 'ai' || !gameState.player2.alive) return;

            const now = Date.now();
            const MOVE_SPEED = 4;
            const ai = gameState.player2;
            const player = gameState.player1;

            if (!player.alive) return;

            const dx = player.x - ai.x;
            const dy = player.y - ai.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            ai.facingRight = dx > 0;

            const weapon = WEAPONS[ai.weapon];
            const optimalRange = weapon.projectileType === 'melee' ? 60 :
                                weapon.name === 'Shotgun' ? 150 :
                                weapon.name === 'RPG' ? 300 : 200;

            const leftEdge = 10;
            const rightEdge = canvas.width - PLAYER_SIZE - 10;
            const leftBuildingEdge = 340;
            const rightBuildingEdge = 560;

            const nearLeftEdge = ai.x < leftBuildingEdge + 20;
            const nearRightEdge = ai.x > rightBuildingEdge - 20;
            const onLeftBuilding = ai.x < leftBuildingEdge;
            const onRightBuilding = ai.x > rightBuildingEdge;
            const inGap = !onLeftBuilding && !onRightBuilding;

            let desiredVelocityX = 0;

            if (ai.onGround) {
                if (nearLeftEdge && onLeftBuilding && ai.velocityX < 0) {
                    desiredVelocityX = 0;
                } else if (nearRightEdge && onRightBuilding && ai.velocityX > 0) {
                    desiredVelocityX = 0;
                } else if (ai.x < leftEdge) {
                    desiredVelocityX = MOVE_SPEED;
                } else if (ai.x > rightEdge) {
                    desiredVelocityX = -MOVE_SPEED;
                } else {
                    if (distance > optimalRange + 50) {
                        desiredVelocityX = dx > 0 ? MOVE_SPEED : -MOVE_SPEED;
                    } else if (distance < optimalRange - 50) {
                        desiredVelocityX = dx > 0 ? -MOVE_SPEED : MOVE_SPEED;
                    }

                    if (onLeftBuilding && desiredVelocityX > 0 && ai.x > leftBuildingEdge - 40) {
                        desiredVelocityX = 0;
                    }
                    if (onRightBuilding && desiredVelocityX < 0 && ai.x < rightBuildingEdge + 40) {
                        desiredVelocityX = 0;
                    }
                }

                ai.velocityX = desiredVelocityX;
            }

            if (inGap && ai.onGround && now - aiState.lastJump > 300) {
                jump(ai);
                aiState.lastJump = now;
            }

            if (player.y < ai.y - 100 && ai.onGround && now - aiState.lastJump > 800 && Math.random() < 0.5) {
                jump(ai);
                aiState.lastJump = now;
            }

            if (!inGap && ai.onGround && Math.abs(dy) < 50 && Math.random() < 0.015) {
                jump(ai);
                aiState.lastJump = now;
            }

            const canShoot = (weapon.projectileType === 'melee' && distance < 60) ||
                           (weapon.projectileType !== 'melee' && distance < 450);

            const hasLineOfSight = Math.abs(dy) < 150;

            if (canShoot && hasLineOfSight && now - aiState.lastShot > weapon.fireRate * 1.1) {
                shoot(ai);
                aiState.lastShot = now;
            }

            if (now - aiState.lastWeaponSwitch > 4000) {
                const preferredWeapon = distance < 80 ? 'axe' :
                                      distance < 180 ? 'shotgun' :
                                      distance < 300 ? 'smg' :
                                      distance > 400 && Math.random() < 0.4 ? 'rpg' : 'pistol';

                if (ai.weapon !== preferredWeapon) {
                    const targetIndex = normalWeaponKeys.indexOf(preferredWeapon);
                    if (targetIndex !== -1) {
                        ai.weaponIndex = targetIndex;
                        ai.weapon = normalWeaponKeys[targetIndex];
                        aiState.lastWeaponSwitch = now;
                    }
                }
            }
        }

        function restartToMenu() {
            // Reset game state
            gameMode = null;
            gameStarted = false;
            gameState.gameOver = false;
            gameState.roundOver = false;
            secretCode = '';
            hasSecretWeapon = false;
            madHoppsActive = false;

            // Reset player 1
            gameState.player1.x = 150;
            gameState.player1.y = ROOFTOP_HEIGHT - PLAYER_SIZE;
            gameState.player1.velocityX = 0;
            gameState.player1.velocityY = 0;
            gameState.player1.rotation = 0;
            gameState.player1.rotationVelocity = 0;
            gameState.player1.onGround = true;
            gameState.player1.score = 0;
            gameState.player1.alive = true;
            gameState.player1.health = MAX_HEALTH;
            gameState.player1.weapon = 'pistol';
            gameState.player1.weaponIndex = 0;
            gameState.player1.facingRight = true;

            // Reset player 2
            gameState.player2.x = 750;
            gameState.player2.y = ROOFTOP_HEIGHT - PLAYER_SIZE;
            gameState.player2.velocityX = 0;
            gameState.player2.velocityY = 0;
            gameState.player2.rotation = 0;
            gameState.player2.rotationVelocity = 0;
            gameState.player2.onGround = true;
            gameState.player2.score = 0;
            gameState.player2.alive = true;
            gameState.player2.health = MAX_HEALTH;
            gameState.player2.weapon = 'pistol';
            gameState.player2.weaponIndex = 0;
            gameState.player2.facingRight = false;

            // Clear projectiles and effects
            gameState.bullets = [];
            gameState.particles = [];
            gameState.muzzleFlashes = [];
            gameState.explosions = [];

            // Show mode select menu
            document.getElementById('modeSelect').style.display = 'block';
            document.getElementById('instructions').textContent = 'Player 1: W=Left, E=Right, Space=Jump, J=Shoot, K=Switch Weapon | Player 2: WASD=Move/Jump, Q=Shoot, T=Switch Weapon\nWeapons: Pistol, SMG, Shotgun, RPG, Axe | First to 5 wins!';

            updateScore();
        }

        function handleInput() {
            if (!gameStarted) return;

            const now = Date.now();
            const MOVE_SPEED = 4;

            // Player 1 controls: W=Left, E=Right, Space=Jump, J=Shoot, K=Switch Weapon
            if (keys[' ']) {
                jump(gameState.player1);
            }
            if (keys.w && gameState.player1.alive) {
                gameState.player1.velocityX = -MOVE_SPEED;
                gameState.player1.facingRight = false;
            }
            if (keys.e && gameState.player1.alive) {
                gameState.player1.velocityX = MOVE_SPEED;
                gameState.player1.facingRight = true;
            }
            if (keys.j) {
                const weapon = WEAPONS[gameState.player1.weapon];
                if (now - lastShot1 > weapon.fireRate) {
                    shoot(gameState.player1);
                    lastShot1 = now;
                }
            }
            if (keys.k && now - lastWeaponSwitch1 > 200) {
                switchWeapon(gameState.player1);
                lastWeaponSwitch1 = now;
            }

            if (gameMode === 'pvp') {
                // Player 2 controls: WASD=Move/Jump, Q=Shoot, T=Switch Weapon
                if (keys.w) {
                    jump(gameState.player2);
                }
                if (keys.a && gameState.player2.alive) {
                    gameState.player2.velocityX = -MOVE_SPEED;
                    gameState.player2.facingRight = false;
                }
                if (keys.d && gameState.player2.alive) {
                    gameState.player2.velocityX = MOVE_SPEED;
                    gameState.player2.facingRight = true;
                }
                if (keys.q) {
                    const weapon = WEAPONS[gameState.player2.weapon];
                    if (now - lastShot2 > weapon.fireRate) {
                        shoot(gameState.player2);
                        lastShot2 = now;
                    }
                }
                if (keys.t && now - lastWeaponSwitch2 > 200) {
                    switchWeapon(gameState.player2);
                    lastWeaponSwitch2 = now;
                }
            }
        }

        function updatePlayer(player) {
            if (!player.alive) {
                // When anyone dies, reset the round
                if (player === gameState.player1) {
                    gameState.player2.score++;
                } else {
                    gameState.player1.score++;
                }
                resetRound();
                return;
            }

            player.velocityY += GRAVITY;
            player.y += player.velocityY;
            player.x += player.velocityX;

            player.x = Math.max(0, Math.min(canvas.width - PLAYER_SIZE, player.x));

            if (player.onGround) {
                player.velocityX *= 0.8;
            } else {
                player.velocityX *= 0.95;
            }

            if (player.y >= ROOFTOP_HEIGHT - PLAYER_SIZE) {
                const onLeftBuilding = player.x + PLAYER_SIZE / 2 < 350;
                const onRightBuilding = player.x + PLAYER_SIZE / 2 > 550;

                if (onLeftBuilding || onRightBuilding) {
                    player.y = ROOFTOP_HEIGHT - PLAYER_SIZE;
                    player.velocityY = 0;
                    player.onGround = true;
                    player.rotation = 0;
                    player.rotationVelocity = 0;
                } else {
                    player.onGround = false;
                }
            } else {
                player.onGround = false;
            }

            player.rotation += player.rotationVelocity;
            player.rotationVelocity *= 0.95;

            // Check if player fell into gap - respawn on nearest rooftop
            const inGap = player.x + PLAYER_SIZE / 2 > 350 && player.x + PLAYER_SIZE / 2 < 550;
            const fellIntoGap = inGap && player.y > ROOFTOP_HEIGHT + 50;

            if (fellIntoGap) {
                // Respawn on nearest rooftop
                const centerX = player.x + PLAYER_SIZE / 2;
                const leftBuildingCenter = 175;
                const rightBuildingCenter = 725;

                if (Math.abs(centerX - leftBuildingCenter) < Math.abs(centerX - rightBuildingCenter)) {
                    // Respawn on left building
                    player.x = 150;
                } else {
                    // Respawn on right building
                    player.x = 750;
                }
                player.y = ROOFTOP_HEIGHT - PLAYER_SIZE;
                player.velocityX = 0;
                player.velocityY = 0;
                player.rotation = 0;
                player.rotationVelocity = 0;
                player.onGround = true;
            }

            // Check if fell completely off screen - reset round
            if (player.y > canvas.height) {
                if (player === gameState.player1) {
                    gameState.player2.score++;
                } else {
                    gameState.player1.score++;
                }
                resetRound();
            }
        }

        function createExplosion(x, y, owner, damage) {
            gameState.explosions.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 100,
                life: 1.0
            });

            createBulletParticles(x, y, 30);

            [gameState.player1, gameState.player2].forEach(player => {
                if (player !== owner && player.alive) {
                    const dx = player.x + PLAYER_SIZE / 2 - x;
                    const dy = player.y + PLAYER_SIZE / 2 - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 100) {
                        const force = (100 - distance) / 100;
                        player.health -= damage * force;
                        player.velocityY = -15 * force;
                        player.velocityX = (dx / distance) * 20 * force;
                        player.rotationVelocity = (Math.random() - 0.5) * 1.5;

                        if (player.health <= 0) {
                            player.health = 0;
                            player.alive = false;
                        }
                    }
                }
            });
        }

        function updateBullets() {
            gameState.bullets.forEach((bullet, index) => {
                bullet.trail.push({x: bullet.x, y: bullet.y, life: 1.0});
                if (bullet.trail.length > 5) {
                    bullet.trail.shift();
                }

                bullet.velocityY += GRAVITY * 0.5;
                bullet.x += bullet.velocityX;
                bullet.y += bullet.velocityY;

                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y > canvas.height) {
                    if (bullet.type === 'rocket') {
                        createExplosion(bullet.x, bullet.y, bullet.owner, bullet.damage);
                    } else {
                        createBulletParticles(bullet.x, bullet.y, 4);
                    }
                    gameState.bullets.splice(index, 1);
                    return;
                }

                [gameState.player1, gameState.player2].forEach(player => {
                    if (player !== bullet.owner && player.alive) {
                        const dx = bullet.x - (player.x + PLAYER_SIZE / 2);
                        const dy = bullet.y - (player.y + PLAYER_SIZE / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < PLAYER_SIZE / 2) {
                            if (bullet.type === 'rocket') {
                                createExplosion(bullet.x, bullet.y, bullet.owner, bullet.damage);
                            } else {
                                player.health -= bullet.damage;
                                player.velocityY = -10;
                                player.velocityX = bullet.velocityX * 0.5;
                                player.rotationVelocity = (bullet.velocityX > 0 ? 0.6 : -0.6);
                                createBulletParticles(bullet.x, bullet.y, 15);

                                if (player.health <= 0) {
                                    player.health = 0;
                                    player.alive = false;
                                }
                            }
                            gameState.bullets.splice(index, 1);
                        }
                    }
                });
            });

            gameState.explosions = gameState.explosions.filter(exp => {
                exp.radius = Math.min(exp.radius + 5, exp.maxRadius);
                exp.life -= 0.05;
                return exp.life > 0;
            });
        }

        function resetRound() {
            if (gameState.player1.score >= WINNING_SCORE || gameState.player2.score >= WINNING_SCORE) {
                gameState.gameOver = true;
                // Submit to leaderboard if Player 1 wins
                if (gameState.player1.score >= WINNING_SCORE) {
                    Leaderboard.checkAndSubmitScore('rooftop-snipers', 1);
                }
            }

            gameState.player1.x = 150;
            gameState.player1.y = ROOFTOP_HEIGHT - PLAYER_SIZE;
            gameState.player1.velocityX = 0;
            gameState.player1.velocityY = 0;
            gameState.player1.rotation = 0;
            gameState.player1.rotationVelocity = 0;
            gameState.player1.onGround = true;
            gameState.player1.alive = true;
            gameState.player1.health = MAX_HEALTH;
            gameState.player1.facingRight = true;

            // Keep secret weapon if unlocked
            if (hasSecretWeapon) {
                gameState.player1.weapon = 'thomasagun';
                gameState.player1.weaponIndex = weaponKeys.indexOf('thomasagun');
            }

            gameState.player2.x = 750;
            gameState.player2.y = ROOFTOP_HEIGHT - PLAYER_SIZE;
            gameState.player2.velocityX = 0;
            gameState.player2.velocityY = 0;
            gameState.player2.rotation = 0;
            gameState.player2.rotationVelocity = 0;
            gameState.player2.onGround = true;
            gameState.player2.alive = true;
            gameState.player2.health = MAX_HEALTH;
            gameState.player2.facingRight = false;
            gameState.player2.weapon = 'pistol';
            gameState.player2.weaponIndex = 0;

            gameState.bullets = [];
            gameState.particles = [];
            gameState.muzzleFlashes = [];
            gameState.explosions = [];
            updateScore();
        }

        function updateScore() {
            const player2Name = gameMode === 'ai' ? 'AI' : 'Player 2';
            if (gameState.gameOver) {
                const winner = gameState.player1.score >= WINNING_SCORE ? 'Player 1' : player2Name;
                scoreDisplay.textContent = `${winner} Wins! Refresh to play again`;
            } else {
                scoreDisplay.textContent = `Player 1: ${gameState.player1.score} | ${player2Name}: ${gameState.player2.score}`;
            }
        }

        function drawPlayer(player, color) {
            ctx.save();
            ctx.translate(player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2);
            ctx.rotate(player.rotation);

            const flipX = player.facingRight ? 1 : -1;
            ctx.scale(flipX, 1);

            ctx.fillStyle = color;
            ctx.fillRect(-PLAYER_SIZE / 2, -PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);

            ctx.fillStyle = '#000';
            ctx.fillRect(-PLAYER_SIZE / 2 + 5, -PLAYER_SIZE / 2 + 5, 8, 8);

            const weapon = WEAPONS[player.weapon];
            if (weapon.projectileType === 'melee') {
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.moveTo(PLAYER_SIZE / 2, 0);
                ctx.lineTo(PLAYER_SIZE / 2 + 25, -10);
                ctx.lineTo(PLAYER_SIZE / 2 + 30, -5);
                ctx.lineTo(PLAYER_SIZE / 2 + 5, 5);
                ctx.fill();
            } else if (weapon.projectileType === 'rocket') {
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(PLAYER_SIZE / 2, -6, 30, 12);
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(PLAYER_SIZE / 2 + 25, -4, 5, 8);
            } else {
                ctx.fillStyle = '#8B4513';
                const gunLength = weapon.name === 'SMG' ? 18 : weapon.name === 'Shotgun' ? 25 : 20;
                const gunWidth = weapon.name === 'Shotgun' ? 6 : 4;
                ctx.fillRect(PLAYER_SIZE / 2, -gunWidth / 2, gunLength, gunWidth);
            }

            ctx.restore();
        }

        function draw() {
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(0.7, '#B0D4E3');
            skyGradient.addColorStop(1, '#D4E8F0');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const sunGradient = ctx.createRadialGradient(150, 100, 10, 150, 100, 50);
            sunGradient.addColorStop(0, '#FFEB3B');
            sunGradient.addColorStop(0.5, '#FFC107');
            sunGradient.addColorStop(1, 'rgba(255, 193, 7, 0)');
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(150, 100, 50, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 15;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(100 + i * 150, 150 + Math.sin(i) * 30, 25, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, ROOFTOP_HEIGHT + 22, 350, 5);
            ctx.fillRect(550, ROOFTOP_HEIGHT + 22, 350, 5);

            const roofGradient1 = ctx.createLinearGradient(0, ROOFTOP_HEIGHT, 0, ROOFTOP_HEIGHT + 20);
            roofGradient1.addColorStop(0, '#8B6F47');
            roofGradient1.addColorStop(1, '#654321');
            ctx.fillStyle = roofGradient1;
            ctx.fillRect(0, ROOFTOP_HEIGHT, 350, 20);
            ctx.fillRect(550, ROOFTOP_HEIGHT, 350, 20);

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, ROOFTOP_HEIGHT + 20, 350, canvas.height);
            ctx.fillRect(550, ROOFTOP_HEIGHT + 20, 350, canvas.height);

            ctx.fillStyle = '#333';
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(52 + i * 100, ROOFTOP_HEIGHT - 78, 60, 80);

                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(50 + i * 100, ROOFTOP_HEIGHT - 80, 60, 80);

                ctx.fillStyle = 'rgba(100, 150, 200, 0.3)';
                ctx.fillRect(55 + i * 100, ROOFTOP_HEIGHT - 75, 20, 30);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(602 + i * 100, ROOFTOP_HEIGHT - 78, 60, 80);

                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(600 + i * 100, ROOFTOP_HEIGHT - 80, 60, 80);

                ctx.fillStyle = 'rgba(100, 150, 200, 0.3)';
                ctx.fillRect(605 + i * 100, ROOFTOP_HEIGHT - 75, 20, 30);
            }

            gameState.particles.forEach(p => {
                ctx.fillStyle = `rgba(255, 100, 50, ${p.life})`;
                ctx.shadowColor = `rgba(255, 100, 50, ${p.life * 0.8})`;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            gameState.muzzleFlashes.forEach(flash => {
                const flashGradient = ctx.createRadialGradient(
                    flash.x, flash.y, 0,
                    flash.x, flash.y, 20 * flash.life
                );
                flashGradient.addColorStop(0, `rgba(255, 200, 0, ${flash.life})`);
                flashGradient.addColorStop(0.5, `rgba(255, 100, 0, ${flash.life * 0.5})`);
                flashGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = flashGradient;
                ctx.beginPath();
                ctx.arc(flash.x, flash.y, 20 * flash.life, 0, Math.PI * 2);
                ctx.fill();
            });

            drawPlayer(gameState.player1, '#4ECDC4');
            drawPlayer(gameState.player2, '#FF6B6B');

            gameState.explosions.forEach(exp => {
                for (let i = 0; i < 3; i++) {
                    const expGradient = ctx.createRadialGradient(
                        exp.x, exp.y, exp.radius * (0.3 + i * 0.3),
                        exp.x, exp.y, exp.radius * (0.5 + i * 0.3)
                    );
                    const alpha = exp.life * (1 - i * 0.2);
                    expGradient.addColorStop(0, `rgba(255, 255, 100, ${alpha})`);
                    expGradient.addColorStop(0.3, `rgba(255, 150, 0, ${alpha * 0.8})`);
                    expGradient.addColorStop(0.7, `rgba(255, 50, 0, ${alpha * 0.5})`);
                    expGradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                    ctx.fillStyle = expGradient;
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            gameState.bullets.forEach(bullet => {
                bullet.trail.forEach((point, index) => {
                    const alpha = (index / bullet.trail.length) * 0.5;
                    const color = bullet.type === 'rocket' ? '255, 100, 0' : bullet.isThomas ? '138, 43, 226' : '50, 50, 50';
                    ctx.fillStyle = `rgba(${color}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, bullet.type === 'rocket' ? 3 : bullet.isThomas ? 3 : 2, 0, Math.PI * 2);
                    ctx.fill();
                });

                if (bullet.type === 'rocket') {
                    ctx.fillStyle = '#4a4a4a';
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 6, 0, Math.PI * 2);
                    ctx.fill();

                    const flameGradient = ctx.createRadialGradient(
                        bullet.x - bullet.velocityX * 0.5, bullet.y - bullet.velocityY * 0.5, 0,
                        bullet.x - bullet.velocityX * 0.5, bullet.y - bullet.velocityY * 0.5, 10
                    );
                    flameGradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
                    flameGradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    flameGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = flameGradient;
                    ctx.beginPath();
                    ctx.arc(bullet.x - bullet.velocityX * 0.5, bullet.y - bullet.velocityY * 0.5, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (bullet.isThomas) {
                    const bulletGradient = ctx.createRadialGradient(
                        bullet.x, bullet.y, 0,
                        bullet.x, bullet.y, 6
                    );
                    bulletGradient.addColorStop(0, '#FFD700');
                    bulletGradient.addColorStop(0.3, '#FF00FF');
                    bulletGradient.addColorStop(0.6, '#8A2BE2');
                    bulletGradient.addColorStop(1, '#4B0082');
                    ctx.fillStyle = bulletGradient;
                    ctx.shadowColor = '#FF00FF';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    const bulletGradient = ctx.createRadialGradient(
                        bullet.x, bullet.y, 0,
                        bullet.x, bullet.y, 5
                    );
                    bulletGradient.addColorStop(0, '#FFD700');
                    bulletGradient.addColorStop(0.5, '#FFA500');
                    bulletGradient.addColorStop(1, '#FF8C00');
                    ctx.fillStyle = bulletGradient;
                    ctx.shadowColor = '#FFA500';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            function drawHealthBar(player, x, y, label) {
                const barWidth = 150;
                const barHeight = 20;
                const healthPercent = player.health / MAX_HEALTH;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(x, y, barWidth + 20, 60);

                ctx.fillStyle = '#fff';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(label, x + 10, y + 20);

                ctx.fillStyle = '#333';
                ctx.fillRect(x + 10, y + 28, barWidth, barHeight);

                const healthColor = healthPercent > 0.6 ? '#4ade80' :
                                   healthPercent > 0.3 ? '#fbbf24' : '#ef4444';
                ctx.fillStyle = healthColor;
                ctx.fillRect(x + 10, y + 28, barWidth * healthPercent, barHeight);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x + 10, y + 28, barWidth, barHeight);

                ctx.fillStyle = '#fff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`${player.health.toFixed(1)}/${MAX_HEALTH}`, x + 10 + barWidth / 2, y + 43);
            }

            drawHealthBar(gameState.player1, 10, 10, 'Player 1');
            const p2Label = gameMode === 'ai' ? 'AI' : 'Player 2';
            drawHealthBar(gameState.player2, 10, 80, p2Label);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 150, 200, 40);
            ctx.fillRect(canvas.width - 210, 10, 200, 40);

            ctx.fillStyle = '#fff';
            ctx.font = '16px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`P1: ${WEAPONS[gameState.player1.weapon].name} [K]`, 20, 175);
            ctx.textAlign = 'right';
            const p2LabelShort = gameMode === 'ai' ? 'AI' : 'P2';
            const p2Key = gameMode === 'ai' ? '' : ' [Q]';
            ctx.fillText(`${p2LabelShort}: ${WEAPONS[gameState.player2.weapon].name}${p2Key}`, canvas.width - 20, 35);

            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = '48px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 15;
                const player2Name = gameMode === 'ai' ? 'AI' : 'Player 2';
                const winner = gameState.player1.score >= WINNING_SCORE ? 'Player 1' : player2Name;
                ctx.fillText(`${winner} Wins!`, canvas.width / 2, canvas.height / 2);

                ctx.font = '24px Courier New';
                ctx.fillText('Refresh to play again', canvas.width / 2, canvas.height / 2 + 50);
                ctx.shadowBlur = 0;
            }

            if (!gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = '36px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Select Game Mode', canvas.width / 2, canvas.height / 2 - 50);
            }
        }

        function gameLoop() {
            if (!gameState.gameOver && gameStarted) {
                handleInput();
                updateAI();
                updatePlayer(gameState.player1);
                updatePlayer(gameState.player2);
                updateBullets();
            }
            updateParticles();
            draw();
            requestAnimationFrame(gameLoop);
        }

        updateScore();
        gameLoop();
    </script>
</body>
</html>
