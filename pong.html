<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            text-align: center;
        }
        canvas {
            border: 2px solid #fff;
            display: block;
            margin: 0 auto;
        }
        #score {
            color: #fff;
            font-size: 24px;
            margin-top: 20px;
        }
        #instructions {
            color: #888;
            font-size: 14px;
            margin-top: 10px;
        }
        #backButton {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #backButton:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="pongCanvas" width="800" height="600"></canvas>
        <div id="score">Player: 0 | AI: 0</div>
        <div id="instructions">Use W/E or Arrow Up/Down to move | Press SPACE to start</div>
        <button id="backButton" onclick="window.location.href='index.html'">Back to Menu</button>
    </div>

    <script>
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        const PADDLE_WIDTH = 10;
        const PADDLE_HEIGHT = 100;
        const BALL_SIZE = 10;
        const WINNING_SCORE = 5;

        let gameState = {
            player: {
                x: 10,
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                dy: 0,
                score: 0,
                velocityY: 0,
                isJumping: false
            },
            ai: {
                x: canvas.width - PADDLE_WIDTH - 10,
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                score: 0
            },
            ball: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                dx: 0,
                dy: 0,
                speed: 5,
                size: BALL_SIZE,
                spin: 0,
                rotation: 0
            },
            particles: [],
            trail: [],
            gameStarted: false,
            gameOver: false
        };

        const keys = {
            w: false,
            e: false,
            ArrowUp: false,
            ArrowDown: false,
            space: false
        };

        // Cheat code tracking
        let typedChars = '';
        let cheatActive = false;

        document.addEventListener('keydown', (e) => {
            // Track typed characters for cheat code
            if (!gameState.gameStarted && e.key.length === 1) {
                typedChars += e.key.toLowerCase();
                if (typedChars.length > 20) {
                    typedChars = typedChars.slice(-20);
                }
                if (typedChars.includes('mad hopps')) {
                    cheatActive = true;
                    console.log('Cheat activated: Mad Hopps!');
                }
            }

            if (e.key in keys) {
                keys[e.key] = true;
                e.preventDefault();
            }
            if (e.key === ' ') {
                keys.space = true;
                e.preventDefault();
                // Only start game if cheat is not active
                if (!cheatActive && !gameState.gameStarted && !gameState.gameOver) {
                    startGame();
                } else if (gameState.gameOver) {
                    resetGame();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
            }
            if (e.key === ' ') {
                keys.space = false;
            }
        });

        function startGame() {
            gameState.gameStarted = true;
            const angle = (Math.random() - 0.5) * Math.PI / 3;
            const direction = Math.random() < 0.5 ? 1 : -1;
            gameState.ball.dx = Math.cos(angle) * gameState.ball.speed * direction;
            gameState.ball.dy = Math.sin(angle) * gameState.ball.speed;
        }

        function resetGame() {
            gameState.player.score = 0;
            gameState.ai.score = 0;
            gameState.gameOver = false;
            gameState.gameStarted = false;
            gameState.player.velocityY = 0;
            gameState.player.isJumping = false;
            typedChars = '';
            cheatActive = false;
            resetBall();
            updateScore();
        }

        function resetBall() {
            gameState.ball.x = canvas.width / 2;
            gameState.ball.y = canvas.height / 2;
            gameState.ball.dx = 0;
            gameState.ball.dy = 0;
            gameState.ball.speed = 5;
            gameState.ball.spin = 0;
            gameState.ball.rotation = 0;
            gameState.particles = [];
            gameState.trail = [];
            gameState.gameStarted = false;
        }

        function createParticles(x, y, count = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (2 + Math.random() * 2),
                    vy: Math.sin(angle) * (2 + Math.random() * 2),
                    life: 1.0,
                    size: 2 + Math.random() * 2
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        function updateScore() {
            if (gameState.gameOver) {
                const winner = gameState.player.score >= WINNING_SCORE ? 'Player' : 'AI';
                scoreDisplay.textContent = `${winner} Wins! Press SPACE to play again`;
            } else {
                scoreDisplay.textContent = `Player: ${gameState.player.score} | AI: ${gameState.ai.score}`;
            }
        }

        function movePaddles() {
            const PADDLE_SPEED = 6;
            const GRAVITY = 0.5;
            const JUMP_POWER = -15;

            if (cheatActive) {
                // Apply gravity when cheat is active
                gameState.player.velocityY += GRAVITY;

                // Jump when space is held and on ground
                if (keys.space && gameState.player.y >= canvas.height - PADDLE_HEIGHT - 5) {
                    gameState.player.velocityY = JUMP_POWER;
                    gameState.player.isJumping = true;
                }

                // Apply vertical velocity
                gameState.player.y += gameState.player.velocityY;

                // Ground collision
                if (gameState.player.y >= canvas.height - PADDLE_HEIGHT) {
                    gameState.player.y = canvas.height - PADDLE_HEIGHT;
                    gameState.player.velocityY = 0;
                    gameState.player.isJumping = false;
                }

                // Ceiling collision
                if (gameState.player.y < 0) {
                    gameState.player.y = 0;
                    gameState.player.velocityY = 0;
                }
            } else {
                // Normal paddle movement
                if ((keys.w || keys.ArrowUp) && gameState.player.y > 0) {
                    gameState.player.y -= PADDLE_SPEED;
                }
                if ((keys.e || keys.ArrowDown) && gameState.player.y < canvas.height - PADDLE_HEIGHT) {
                    gameState.player.y += PADDLE_SPEED;
                }
            }

            const aiCenter = gameState.ai.y + PADDLE_HEIGHT / 2;
            const ballCenter = gameState.ball.y;
            const AI_SPEED = 4;

            if (gameState.ball.dx > 0) {
                if (ballCenter < aiCenter - 10 && gameState.ai.y > 0) {
                    gameState.ai.y -= AI_SPEED;
                } else if (ballCenter > aiCenter + 10 && gameState.ai.y < canvas.height - PADDLE_HEIGHT) {
                    gameState.ai.y += AI_SPEED;
                }
            }
        }

        function moveBall() {
            if (!gameState.gameStarted) return;

            gameState.trail.push({
                x: gameState.ball.x + BALL_SIZE / 2,
                y: gameState.ball.y + BALL_SIZE / 2,
                life: 1.0
            });
            if (gameState.trail.length > 10) {
                gameState.trail.shift();
            }

            gameState.ball.dy += gameState.ball.spin * 0.1;
            gameState.ball.x += gameState.ball.dx;
            gameState.ball.y += gameState.ball.dy;
            gameState.ball.rotation += gameState.ball.spin;

            if (gameState.ball.y <= 0 || gameState.ball.y >= canvas.height - BALL_SIZE) {
                gameState.ball.dy *= -0.95;
                gameState.ball.spin *= 0.8;
                createParticles(gameState.ball.x + BALL_SIZE / 2, gameState.ball.y + BALL_SIZE / 2, 6);
            }

            if (checkCollision(gameState.ball, gameState.player) ||
                checkCollision(gameState.ball, gameState.ai)) {

                const paddle = checkCollision(gameState.ball, gameState.player) ?
                    gameState.player : gameState.ai;

                const collidePoint = (gameState.ball.y + BALL_SIZE / 2) - (paddle.y + PADDLE_HEIGHT / 2);
                const normalizedCollidePoint = collidePoint / (PADDLE_HEIGHT / 2);
                const bounceAngle = normalizedCollidePoint * (Math.PI / 4);

                const direction = paddle === gameState.player ? 1 : -1;
                gameState.ball.dx = direction * gameState.ball.speed * Math.cos(bounceAngle);
                gameState.ball.dy = gameState.ball.speed * Math.sin(bounceAngle);
                gameState.ball.spin = normalizedCollidePoint * 0.5;

                gameState.ball.speed = Math.min(gameState.ball.speed * 1.05, 12);

                createParticles(gameState.ball.x + BALL_SIZE / 2, gameState.ball.y + BALL_SIZE / 2, 12);
            }

            if (gameState.ball.x < 0) {
                gameState.ai.score++;
                updateScore();
                if (gameState.ai.score >= WINNING_SCORE) {
                    gameState.gameOver = true;
                } else {
                    resetBall();
                }
            } else if (gameState.ball.x > canvas.width) {
                gameState.player.score++;
                updateScore();
                if (gameState.player.score >= WINNING_SCORE) {
                    gameState.gameOver = true;
                } else {
                    resetBall();
                }
            }
        }

        function checkCollision(ball, paddle) {
            return ball.x < paddle.x + paddle.width &&
                   ball.x + ball.size > paddle.x &&
                   ball.y < paddle.y + paddle.height &&
                   ball.y + ball.size > paddle.y;
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#444';
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            gameState.trail.forEach((point, index) => {
                const alpha = (index / gameState.trail.length) * 0.3;
                const size = (index / gameState.trail.length) * BALL_SIZE;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            gameState.particles.forEach(p => {
                ctx.fillStyle = `rgba(255, 255, 255, ${p.life * 0.8})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 10;

            const gradient1 = ctx.createLinearGradient(
                gameState.player.x, gameState.player.y,
                gameState.player.x + gameState.player.width, gameState.player.y + gameState.player.height
            );
            gradient1.addColorStop(0, '#fff');
            gradient1.addColorStop(1, '#ccc');
            ctx.fillStyle = gradient1;
            ctx.fillRect(gameState.player.x, gameState.player.y,
                        gameState.player.width, gameState.player.height);

            const gradient2 = ctx.createLinearGradient(
                gameState.ai.x, gameState.ai.y,
                gameState.ai.x + gameState.ai.width, gameState.ai.y + gameState.ai.height
            );
            gradient2.addColorStop(0, '#fff');
            gradient2.addColorStop(1, '#ccc');
            ctx.fillStyle = gradient2;
            ctx.fillRect(gameState.ai.x, gameState.ai.y,
                        gameState.ai.width, gameState.ai.height);

            ctx.save();
            ctx.translate(gameState.ball.x + BALL_SIZE / 2, gameState.ball.y + BALL_SIZE / 2);
            ctx.rotate(gameState.ball.rotation);

            const ballGradient = ctx.createRadialGradient(
                -BALL_SIZE / 4, -BALL_SIZE / 4, 0,
                0, 0, BALL_SIZE
            );
            ballGradient.addColorStop(0, '#fff');
            ballGradient.addColorStop(0.7, '#ddd');
            ballGradient.addColorStop(1, '#aaa');
            ctx.fillStyle = ballGradient;
            ctx.beginPath();
            ctx.arc(0, 0, BALL_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-BALL_SIZE / 2, 0);
            ctx.lineTo(BALL_SIZE / 2, 0);
            ctx.moveTo(0, -BALL_SIZE / 2);
            ctx.lineTo(0, BALL_SIZE / 2);
            ctx.stroke();

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function gameLoop() {
            if (!gameState.gameOver) {
                movePaddles();
                moveBall();
            }
            updateParticles();
            draw();
            requestAnimationFrame(gameLoop);
        }

        updateScore();
        gameLoop();
    </script>
</body>
</html>
